@Autowired - as we know, used to inject beans under packages which are scanned through component scan.

	this can be used for autowiring interfaces also. In this cases, when we can call some method through this interface reference, the actual method called will be of implementation class of that interface.
	
	However, if multiple classes implements same interface, then comes the ambiguity error (run time).

@Qualifier -- in addition to @Autowired, if we use @Qualifier("<name of the bean class in camel case>"), that problem is solved!

	ex: if the implementation class name is PhonePe -- then the above name should be 'phonePe'
	
	Now, the question is we are hardcoding the qualifier bean, how to pass it in run time ??
	
	if we take the value from properties file and pass it inside the @Qualifier annotation. it won't work. It's not like value is not getting from properties file. value is able to be fetched, but it's the annotation which is not able to apply it.
	
	Ex: which won't work -- 
	
		@Autowired
		@Qualifier("${beanName}")

@Resource -- this annotation with dynamic parameter will serve the purpose alone without @Autowired
	
		@Resource(name="${beanName}")
		
		-- So, it is the combination of @Autowired and @Qualifier and dynamic usage
		

@Inject : 
	1. @Inject annotation is same as @Autowired annotation â€“ a way of telling Spring framework to find out dependencies of the bean, instead of you mentioning it explicitly
	2. But if both annotations do the same thing, then why we need 2 annotations for same kind of functionality ðŸ¤” ?
		ðŸ‘‰ @Autowired annotation is the one specific to Spring framework.
		ðŸ‘‰ But @Inject is an standard annotation based on JSR-330 annotation collections.
		ðŸ‘‰ In a nutshell, JSR-330 defines a standard set of annotations for dependency injection.
		ðŸ‘‰ If any dependency injection framework like Spring, wants to comply with the standard, they have to support these standard annotations.
	3. âœ… So, if you use @Inject annotation in place of @Autowired, you are making your application portable from Spring framework to any other standard dependency injection framework like Google Guice ðŸ˜Š.
	4.So, does this mean that you should always use @Inject annotation ? ðŸ˜³ If there is a possibility of changing DI framework from Spring to something else which also supports JSR-330 standard, then it would better to use standard JSR-330 annotations so that there would be minimal changes while migrating.